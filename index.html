<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subway Runner - JavaScript</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            border: 3px solid #444;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }
        .instructions {
            color: white;
            text-align: center;
            margin-top: 20px;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
        }
        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="score-display" id="scoreDisplay">Score: 0</div>
    <div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="instructions">
            <p>Use LEFT/RIGHT arrows to change lanes, SPACE to jump. Avoid obstacles and collect coins! Press R to restart after game over.</p>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');

        // Colors
        const WHITE = '#FFFFFF';
        const BLACK = '#000000';
        const RED = '#FF0000';
        const GREEN = '#00FF00';
        const BLUE = '#0078FF';
        const YELLOW = '#FFFF00';
        const GRAY = '#646464';
        const BROWN = '#8B4513';
        const DARK_GRAY = '#333333';
        const LIGHT_GRAY = '#888888';

        // Game variables
        let score = 0;
        let gameOver = false;
        let gameSpeed = 5;
        let obstacleTimer = 0;
        let coinTimer = 0;
        let backgroundOffset = 0;

        // Player class
        class Player {
            constructor() {
                this.width = 40;
                this.height = 60;
                this.lanes = [canvas.width/2 - 100, canvas.width/2, canvas.width/2 + 100];
                this.currentLane = 1; // 0: left, 1: middle, 2: right
                this.x = this.lanes[this.currentLane];
                this.y = canvas.height - 150;
                this.jumpVelocity = 0;
                this.isJumping = false;
            }
            
            draw() {
                // Draw player as a simple character
                ctx.fillStyle = BLUE;
                ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                
                // Draw head
                ctx.fillStyle = '#FFB6C1'; // Light pink for face
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.height - 15, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw eyes
                ctx.fillStyle = BLACK;
                ctx.beginPath();
                ctx.arc(this.x - 8, this.y - this.height - 20, 4, 0, Math.PI * 2);
                ctx.arc(this.x + 8, this.y - this.height - 20, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            jump() {
                if (!this.isJumping) {
                    this.jumpVelocity = -15;
                    this.isJumping = true;
                }
            }
            
            update() {
                // Handle jumping physics
                if (this.isJumping) {
                    this.y += this.jumpVelocity;
                    this.jumpVelocity += 0.8; // Gravity
                    
                    // Check if landed
                    if (this.y >= canvas.height - 150) {
                        this.y = canvas.height - 150;
                        this.isJumping = false;
                    }
                }
                
                // Update x position based on current lane
                const targetX = this.lanes[this.currentLane];
                if (this.x < targetX) {
                    this.x += Math.min(10, targetX - this.x);
                } else if (this.x > targetX) {
                    this.x -= Math.min(10, this.x - targetX);
                }
            }
            
            moveLeft() {
                if (this.currentLane > 0) {
                    this.currentLane -= 1;
                }
            }
            
            moveRight() {
                if (this.currentLane < 2) {
                    this.currentLane += 1;
                }
            }
            
            getRect() {
                return {
                    x: this.x - this.width/2 + 10,
                    y: this.y - this.height + 10,
                    width: this.width - 20,
                    height: this.height - 20
                };
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(lane) {
                this.width = 50;
                this.height = 50;
                this.lanes = [canvas.width/2 - 100, canvas.width/2, canvas.width/2 + 100];
                this.x = this.lanes[lane];
                this.y = -this.height;
                this.speed = gameSpeed;
                this.type = Math.random() > 0.5 ? 'barrier' : 'hole';
            }
            
            draw() {
                if (this.type === 'barrier') {
                    // Draw a barrier obstacle
                    ctx.fillStyle = RED;
                    ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                    
                    // Draw warning stripes
                    ctx.fillStyle = YELLOW;
                    for (let i = 0; i < this.width; i += 10) {
                        ctx.fillRect(this.x - this.width/2 + i, this.y, 5, this.height);
                    }
                } else {
                    // Draw a hole obstacle
                    ctx.fillStyle = DARK_GRAY;
                    ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                    
                    // Draw hole depth
                    ctx.fillStyle = BLACK;
                    ctx.fillRect(this.x - this.width/2 + 5, this.y + 5, this.width - 10, this.height - 10);
                }
            }
            
            update() {
                this.y += this.speed;
                this.speed = gameSpeed; // Update speed in case gameSpeed changed
            }
            
            getRect() {
                return {
                    x: this.x - this.width/2,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            isOffScreen() {
                return this.y > canvas.height;
            }
        }

        // Coin class
        class Coin {
            constructor(lane) {
                this.width = 30;
                this.height = 30;
                this.lanes = [canvas.width/2 - 100, canvas.width/2, canvas.width/2 + 100];
                this.x = this.lanes[lane];
                this.y = -this.height;
                this.speed = gameSpeed;
                this.collected = false;
            }
            
            draw() {
                if (this.collected) return;
                
                ctx.fillStyle = YELLOW;
                ctx.beginPath();
                ctx.arc(this.x, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(this.x, this.y + this.height/2, this.width/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Shine effect
                ctx.fillStyle = WHITE;
                ctx.beginPath();
                ctx.arc(this.x - 5, this.y + this.height/2 - 5, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            update() {
                this.y += this.speed;
            }
            
            getRect() {
                return {
                    x: this.x - this.width/2,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            isOffScreen() {
                return this.y > canvas.height;
            }
        }

        // Draw background
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Moving clouds
            ctx.fillStyle = WHITE;
            for (let i = 0; i < 5; i++) {
                const x = (i * 200 + backgroundOffset * 0.5) % (canvas.width + 200) - 100;
                ctx.beginPath();
                ctx.arc(x, 80, 30, 0, Math.PI * 2);
                ctx.arc(x + 40, 70, 25, 0, Math.PI * 2);
                ctx.arc(x + 80, 80, 30, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ground
            ctx.fillStyle = BROWN;
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
            
            // Road with lanes
            ctx.fillStyle = DARK_GRAY;
            ctx.fillRect(canvas.width/2 - 150, canvas.height - 100, 300, 100);
            
            // Lane markings
            ctx.strokeStyle = YELLOW;
            ctx.lineWidth = 3;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(canvas.width/2 - 150, canvas.height - 50);
            ctx.lineTo(canvas.width/2 + 150, canvas.height - 50);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(canvas.width/2 - 50, canvas.height - 100);
            ctx.lineTo(canvas.width/2 - 50, canvas.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(canvas.width/2 + 50, canvas.height - 100);
            ctx.lineTo(canvas.width/2 + 50, canvas.height);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Sidewalk
            ctx.fillStyle = LIGHT_GRAY;
            ctx.fillRect(canvas.width/2 - 200, canvas.height - 100, 50, 100);
            ctx.fillRect(canvas.width/2 + 150, canvas.height - 100, 50, 100);
        }

        // Check collision between two rectangles
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Create player instance
        const player = new Player();

        // Arrays to store game objects
        let obstacles = [];
        let coins = [];

        // Game loop function
        function gameLoop() {
            if (gameOver) {
                // Draw game over screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = WHITE;
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 50);
                
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2);
                ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 50);
                return;
            }
            
            // Clear canvas with background
            drawBackground();
            backgroundOffset += gameSpeed * 0.5;
            
            // Update game objects
            player.update();
            
            // Update obstacles
            obstacles.forEach((obstacle, index) => {
                obstacle.update();
                if (obstacle.isOffScreen()) {
                    obstacles.splice(index, 1);
                    score += 1; // Score for avoiding obstacles
                }
            });
            
            // Update coins
            coins.forEach((coin, index) => {
                coin.update();
                if (coin.isOffScreen()) {
                    coins.splice(index, 1);
                }
                
                // Check coin collection
                if (!coin.collected && checkCollision(player.getRect(), coin.getRect())) {
                    coin.collected = true;
                    score += 5; // Bonus points for coins
                    coins.splice(index, 1);
                }
            });
            
            // Spawn new obstacles
            obstacleTimer++;
            if (obstacleTimer > 120 - Math.min(100, score)) { // Spawn faster as score increases
                const lane = Math.floor(Math.random() * 3);
                obstacles.push(new Obstacle(lane));
                obstacleTimer = 0;
            }
            
            // Spawn new coins
            coinTimer++;
            if (coinTimer > 180) {
                const lane = Math.floor(Math.random() * 3);
                coins.push(new Coin(lane));
                coinTimer = 0;
            }
            
            // Check collisions with obstacles
            obstacles.forEach(obstacle => {
                if (checkCollision(player.getRect(), obstacle.getRect())) {
                    gameOver = true;
                }
            });
            
            // Increase game speed gradually
            gameSpeed = 5 + Math.floor(score / 50);
            
            // Draw everything
            obstacles.forEach(obstacle => obstacle.draw());
            coins.forEach(coin => coin.draw());
            player.draw();
            
            // Update score display
            scoreDisplay.textContent = `Score: ${score}`;
            
            // Draw speed indicator
            ctx.fillStyle = WHITE;
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`Speed: ${gameSpeed.toFixed(1)}`, canvas.width - 20, 30);
            
            // Continue loop
            requestAnimationFrame(gameLoop);
        }

        // Input handlers
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') player.moveLeft();
            if (e.code === 'ArrowRight') player.moveRight();
            if (e.code === 'Space') player.jump();
            if (e.code === 'KeyR' && gameOver) {
                // Restart game
                score = 0;
                gameOver = false;
                gameSpeed = 5;
                obstacles = [];
                coins = [];
                player.currentLane = 1;
                player.x = player.lanes[1];
                player.y = canvas.height - 150;
                player.isJumping = false;
                gameLoop();
            }
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            if (touchX < canvas.width / 2) {
                player.moveLeft();
            } else {
                player.moveRight();
            }
            player.jump();
        });

        // Start the game
        gameLoop();
    </script>
</body>
</html>
